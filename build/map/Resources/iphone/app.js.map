{"version":3,"sources":["/Users/samueleast/.appcelerator/install/7.1.1/package/node_modules/alloy/Alloy/template/app.js","app/alloy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AD1UA","file":"/Users/samueleast/Documents/Appcelerator_Studio_Workspace/OTNet/Resources/iphone/app.js","sourceRoot":"/Users/samueleast/Documents/Appcelerator_Studio_Workspace/OTNet","sourcesContent":["/**\n * Alloy for Titanium by Appcelerator\n * This is generated code, DO NOT MODIFY - changes will be lost!\n * Copyright (c) 2012 by Appcelerator, Inc.\n */\nvar Alloy = require('/alloy'),\n\t_ = Alloy._,\n\tBackbone = Alloy.Backbone;\n\n__MAPMARKER_ALLOY_JS__\nAlloy.createController('index');","/**\n * Movies\n * \n * @copyright\n * Copyright (c) 2015 by Appcelerator, Inc. All Rights Reserved.\n *\n * @license\n * Licensed under the terms of the Apache Public License\n * Please see the LICENSE included with this distribution for details.\n */\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Constants\n//\n///////////////////////////////////////////////////////////////////////////////\n\n// properties\nAlloy.Globals.PROPERTY_ENABLE_MOTION_ANIMATION = 'PROPERTY_ENABLE_MOTION_ANIMATION';\nAlloy.Globals.PROPERTY_ENABLE_LIST_ANIMATION = 'PROPERTY_ENABLE_LIST_ANIMATION';\n\n// set default properties\nif (!Ti.App.Properties.hasProperty(Alloy.Globals.PROPERTY_ENABLE_MOTION_ANIMATION)) {\n\tTi.App.Properties.setBool(Alloy.Globals.PROPERTY_ENABLE_MOTION_ANIMATION, true);\n}\nif (!Ti.App.Properties.hasProperty(Alloy.Globals.PROPERTY_ENABLE_LIST_ANIMATION)) {\n\tTi.App.Properties.setBool(Alloy.Globals.PROPERTY_ENABLE_LIST_ANIMATION, true);\n};\n\n// events\nAlloy.Globals.EVENT_PROPERTY_ENABLE_MOTION_ANIMATION_DID_CHANGE = 'EVENT_PROPERTY_ENABLE_MOTION_ANIMATION_DID_CHANGE';\nAlloy.Globals.EVENT_PROPERTY_ENABLE_LIST_ANIMATION_DID_CHANGE = 'EVENT_PROPERTY_ENABLE_LIST_ANIMATION_DID_CHANGE';\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Navigation singleton\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * The navigator object which handles all navigation\n * @type {Object}\n */\nAlloy.Globals.Navigator = {};\n\n/**\n * Init navigation\n * Called from index controller once intro animation is complete\n */\nAlloy.Globals.initNavigation = function() {\t\t\n\t// Require in the navigation module\n    Alloy.Globals.Navigator = require(\"/navigation\")({\n        parent: Alloy.Globals.navigationWindow || null\n    });\n};\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Device singleton\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Device information, some come from the Ti API calls and can be referenced\n * from here so multiple bridge calls aren't necessary, others generated here\n * for ease of calculations and such.\n *\n * @type {Object}\n * @param {String} version The version of the OS\n * @param {Number} versionMajor The major version of the OS\n * @param {Number} versionMinor The minor version of the OS\n * @param {Number} width The width of the device screen\n * @param {Number} height The height of the device screen\n * @param {Number} dpi The DPI of the device screen\n * @param {String} orientation The device orientation, either \"landscape\" or \"portrait\"\n * @param {String} statusBarOrientation A Ti.UI orientation value\n */\nAlloy.Globals.Device = {\n\tversion: Ti.Platform.version,\n\tversionMajor: parseInt(Ti.Platform.version.split(\".\")[0], 10),\n\tversionMinor: parseInt(Ti.Platform.version.split(\".\")[1], 10),\n\twidth: (Ti.Platform.displayCaps.platformWidth > Ti.Platform.displayCaps.platformHeight) ? Ti.Platform.displayCaps.platformHeight : Ti.Platform.displayCaps.platformWidth,\n\theight: (Ti.Platform.displayCaps.platformWidth > Ti.Platform.displayCaps.platformHeight) ? Ti.Platform.displayCaps.platformWidth : Ti.Platform.displayCaps.platformHeight,\n\tdpi: Ti.Platform.displayCaps.dpi,\n\torientation: Ti.Gesture.orientation == Ti.UI.LANDSCAPE_LEFT || Ti.Gesture.orientation == Ti.UI.LANDSCAPE_RIGHT ? \"landscape\" : \"portrait\"\n};\n\nif(OS_ANDROID) {\n\tAlloy.Globals.Device.width = (Alloy.Globals.Device.width / (Alloy.Globals.Device.dpi / 160));\n\tAlloy.Globals.Device.height = (Alloy.Globals.Device.height / (Alloy.Globals.Device.dpi / 160));\n}\n\nAlloy.Globals.dpToPx = function(dp) {\n\treturn dp * (Ti.Platform.displayCaps.platformHeight / Alloy.Globals.Device.height);\n};\n\nAlloy.Globals.pxToDp = function(px) {\n\treturn px * (Alloy.Globals.Device.height / Ti.Platform.displayCaps.platformHeight);\n};\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Orientation helpers\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Helper to bind the orientation events to a controller.\n *\n * **NOTE** It is VERY important this is\n * managed right because we're adding global events. They must be removed\n * or a leak can happen because of all the closures. We could slightly\n * reduce the closures if we placed these in the individual controllers\n * but then we're duplicating code. This keeps the controllers clean. Currently,\n * this method will _add_ and _remove_ the global events, so things should go\n * out of scope and GC'd correctly.\n *\n * @param {Controllers} _controller The controller to bind the orientation events\n */\nAlloy.Globals.bindOrientationEvents = function(_controller) {\n\t_controller.window.addEventListener(\"close\", function() {\n\t\tif(_controller.handleOrientation) {\n\t\t\tTi.App.removeEventListener(\"orientationChange\", _controller.handleOrientation);\n\t\t}\n\t});\n\t\n\t_controller.window.addEventListener(\"open\", function() {\n\t\tTi.App.addEventListener(\"orientationChange\", function(_event) {\n\t\t\tif(_controller.handleOrientation) {\n\t\t\t\t_controller.handleOrientation(_event);\n\t\t\t}\n\t\t\t\n\t\t\tsetViewsForOrientation(_controller);\n\t\t});\n\t});\n};\n\n/**\n * Handle the orientation change event callback\n * @param {Object} _event Standard Ti Callback\n */\nfunction orientationChange(_event) {\n\t// Ignore face-up, face-down and unknown orientation\n\tif(_event.orientation === Titanium.UI.FACE_UP || _event.orientation === Titanium.UI.FACE_DOWN || _event.orientation === Titanium.UI.UNKNOWN) {\n\t\treturn;\n\t}\n\n\tAlloy.Globals.Device.orientation = _event.source.landscape ? \"landscape\" : \"portrait\";\n\n\t/**\n\t * Fires an event for orientation change handling throughout the app\n\t * @event orientationChange\n\t */\n\tTi.App.fireEvent(\"orientationChange\", {\n\t\torientation: Alloy.Globals.Device.orientation\n\t});\n}\nTi.Gesture.addEventListener(\"orientationchange\", orientationChange);\n\n/**\n * Update views for current orientation helper\n *\n * We're doing this because Alloy does not have support for\n * orientation support in tss files yet. In order not to duplicate\n * a ton of object properties, hardcode them, etc. we're using this method.\n *\n * Once Alloy has orientation support (e.g. `#myElement[orientation=landscape]`), this\n * can be removed and the tss reworked.\n *\n * All that has to be done is implement the following structure in a `.tss` file:\n * \t\t\"#myElement\": {\n * \t\t\tlandscape: { backgroundColor: \"red\" },\n * \t\t\tportrait: { backgroundColor: \"green\" }\n * \t\t}\n *\n * @param {Controllers} _controller\n */\nfunction setViewsForOrientation(_controller) {\n\tif(!Alloy.Globals.Device.orientation) {\n\t\treturn;\n\t}\n\t\n\t// Restricted the UI for portrait and landscape orientation\n\tif(Alloy.Globals.Device.orientation == \"portrait\" || Alloy.Globals.Device.orientation == \"landscape\") {\n\t\tfor(var view in _controller.__views) {\n\t\t\tif(_controller.__views[view][Alloy.Globals.Device.orientation] && typeof _controller.__views[view].applyProperties == \"function\") {\n\t\t\t\t_controller.__views[view].applyProperties(_controller.__views[view][Alloy.Globals.Device.orientation]);\n\t\t\t} else if(_controller.__views[view].wrapper && _controller.__views[view].wrapper[Alloy.Globals.Device.orientation] && typeof _controller.__views[view].applyProperties == \"function\") {\n\t\t\t\t_controller.__views[view].applyProperties(_controller.__views[view].wrapper[Alloy.Globals.Device.orientation]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Layout\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Calculate element dimensions for given screen size\n * @param {Object} size\t\tcontaining width and height properties\n */\nAlloy.Globals.calculateElementDimensions = function(size) {\n\t\t\n\tvar layout = {};\n\t\n\t// intro\n\tlayout.intro = {};\n\tlayout.intro.clapperTopContainerTop = size.height/2 - 43;\n\tlayout.intro.clapperTopContainerLeft = size.width/2 - 150;\n\tlayout.intro.clapperBottomTop = layout.intro.clapperTopContainerTop + 31;\n\tlayout.intro.clapperBottomLeft = size.width/2 - 50;\n\tlayout.intro.activityViewTop = layout.intro.clapperTopContainerTop + 130;\n\t\n\t// options buttons\n\tlayout.optionButtons = {};\n\tlayout.optionButtons.width = size.width / 3;\n\tlayout.optionButtons.height = layout.optionButtons.width * 0.3; \n\t\n\t// form\n\tlayout.overlay = {};\n\tlayout.overlay.width = (size.width > 400) ? 360 : (size.width - 40);\n\t\n\t// lists\n\tlayout.lists = {};\n\tlayout.lists.userCell = {};\n\tlayout.lists.userCell.width = size.width - 20;\n\tlayout.lists.userCell.imageLeft = -layout.lists.userCell.width / 6;\n\tlayout.lists.userCell.imageWidth = Math.abs(layout.lists.userCell.imageLeft * 2) + layout.lists.userCell.width;\n\tlayout.lists.userCell.imageHeight = Math.ceil(layout.lists.userCell.imageWidth * 9) / 16;\n\t\n\tlayout.lists.cell = {};\n\tlayout.lists.cell.width = (size.width - 30) / 2;\n\tlayout.lists.cell.height = layout.lists.cell.width;\n\tlayout.lists.cell.imageTop = -20;\n\tlayout.lists.cell.imageLeft = -layout.lists.cell.width;\n\tlayout.lists.cell.imageWidth = Math.abs(layout.lists.cell.imageLeft * 2) + layout.lists.cell.width;\n\tlayout.lists.cell.imageHeight = Math.ceil(layout.lists.cell.imageWidth * 9) / 16;\n\t\n\t// movies list\n\tlayout.list = {};\n\tlayout.list.row = {};\n\tlayout.list.row.width = size.width;\n\tlayout.list.row.height = Math.ceil(size.width / 2.5);\n\tlayout.list.row.imageHeight = Math.ceil((size.width * 9) / 16);\n\t\n\t// movie\n\tlayout.movie = {};\n\tlayout.movie.backdropImageLeft = -size.width * 0.15;\n\tlayout.movie.backdropImageWidth = size.width * 1.3;\n\tlayout.movie.backdropImageHeight = Math.ceil((layout.movie.backdropImageWidth * 9) / 16);\n\tlayout.movie.titleTop = layout.movie.backdropImageHeight * 0.5;\n\tlayout.movie.detailsTop = 15; \n\tlayout.movie.posterWidth = Math.ceil(size.width / 3);\n\tlayout.movie.posterHeight = layout.movie.posterWidth * 1.5; \n\tlayout.movie.infoLeft = layout.movie.posterWidth + 15; \n\tlayout.movie.infoWidth = size.width - layout.movie.infoLeft - 20;\n\tlayout.movie.linkButtonTop = 40;\n\tlayout.movie.linkButtonWidth = (layout.movie.infoWidth - 10) / 2;\n\tif (OS_ANDROID) layout.movie.linkButtonWidth -= 1;  \n\tlayout.movie.imdbButtonLeft = layout.movie.infoLeft + layout.movie.linkButtonWidth + 10; \n\tlayout.movie.synopsisTop = 20;\n\t\n\treturn layout;\n};\n\n// Calculate element dimentsions\nAlloy.Globals.layout = Alloy.Globals.calculateElementDimensions(Alloy.Globals.Device);\n\t\n/**\n * Backdrop image size\n * Calculate best size image based on config\n */\nAlloy.Globals.backdropImageSize = 'original';\nAlloy.Globals.setBackdropImageSize = function(sizes) {\n\tAlloy.Globals.backdropImageSize = getBestImageSize(sizes, Alloy.Globals.Device.width);\n\tTi.API.info(\"Backdrop size for \" + Alloy.Globals.Device.width + \": \" + Alloy.Globals.backdropImageSize);\n};\n\n/**\n * Poster image size\n * Calculate best size image based on config\n */\nAlloy.Globals.posterImageSize = 'original';\nAlloy.Globals.setPosterImageSize = function(sizes) {\n\tAlloy.Globals.posterImageSize = getBestImageSize(sizes, Alloy.Globals.layout.movie.posterWidth);\n\tTi.API.info(\"Poster size for \" + Alloy.Globals.layout.movie.posterWidth  + \": \" + Alloy.Globals.posterImageSize);\n};\n\n/**\n * Returns next largest size for given target\n * @param {Array} sizes\t\tlist of size strings\n * @param {Number} target\ttarget size\n */\nfunction getBestImageSize(sizes, target) {\n\tvar bestSizeValue = 999999;\n\tvar bestSize = 'original';\n\tfor (var i=0; i<sizes.length; i++) {\n\t\tvar size = sizes[i];\n\t\tif (size != 'original') {\n\t\t\tvar sizeValue = parseInt(size.substr(1, size.length));\n\t\t\tif (sizeValue < bestSizeValue && sizeValue > target) {\n\t\t\t\tbestSizeValue = sizeValue;\n\t\t\t\tbestSize = size;\n\t\t\t}\n\t\t}\n\t}\n\treturn bestSize;\n}\n\nAlloy.Globals.brand       = '#4f9efb';\nAlloy.Globals.apiKey      = 'wkk0sco0ogk0g0g4sgk8wgswc0wssgcccgoskkc8';\nAlloy.Globals.apiUrl      = 'https://otnet.io';\nAlloy.Globals.playlistsId = 22; \nAlloy.Globals.genresId    = 23; \n\n///////////////////////////////////////////////////////////////////////////////\n//\n// Unit tests\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Unit test runner\n */\nif (!ENV_PRODUCTION) {\n\t// if tests are enabled in config, execute test runner\n\tif (Alloy.CFG.run_logic_tests) {\n\t\trequire('tests/tests_runner');\n\t}\n}\n"]}